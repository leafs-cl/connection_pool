/*
* @Description: Default log implement of mysql connection pool
* @Author: abellli
* @Date: 2025-08-19
* @LastEditTime: 2025-08-19
*/
#pragma once
#include <iostream>
#include <fstream>
#include <mutex>
#include <queue>
#include <thread>
#include <condition_variable>
#include <chrono>
#include <iomanip>
#include <cassert>
#include <atomic>

#include <fmt/core.h>

enum class LogLevel {
    DEBUG, 
    INFO,
    WARN, 
    ERROR, 
    FATAL 
};

class AsyncLogger {
public:
    /**
        * instance() if callled by static method or global construct func, maybe cause conflict between 
        * inner lock and global static init lock
        * even cause cycle dependency between lock
        * For example, instance() call init(), init use INFO_LOGGER, 
        * INFO_LOGGER call instance() to get singleton,
        * cause dead lock
    */ 
    static AsyncLogger& instance() { // Ensure singleton , MAGIC STATIC(High level DCLP, use atomic opt instead of lock check), rely on hidden thread-safe flag generated by compiler
        static AsyncLogger logger;
        return logger;
    }
    void init(const std::string& filename = "app.log", 
              size_t max_size = 10 * 1024 * 1024, // 10M
              size_t max_queue_size = 1000,
              bool drop_when_full = true,
              bool console_output = false) 
    {
        _filename = filename;
        _max_size = max_size;
        _console_output = console_output;  
        _max_queue_size = max_queue_size;
        _drop_when_full = drop_when_full;
        _worker = std::thread(&AsyncLogger::run, this);
    }

    void enable_console_output(bool enable) {
        std::lock_guard<std::mutex> lock(_queue_mutex);
        _console_output = enable;
    }

    void enqueue(LogLevel level, const std::string& message, const char* file, int line) {
        // todo optimze: use self-rotate instead of lock,
        // reduce context switch overhead
        std::unique_lock<std::mutex> lock(_queue_mutex);
        if(_current_queue_size.load() >= _max_queue_size){
            if (_drop_when_full){
                std::cerr << "WARNING: Log Queue is full, dropping msg" << "\n";
            } else{
                _condition_not_full.wait(lock, [this]{
                    return _current_queue_size.load() < _max_queue_size;
                    }
                );
            }
        }
        _log_queue.push({level, message, file, line, std::chrono::system_clock::now()});
        _current_queue_size++;
        _condition.notify_one();
    }

    // Be aware of join(may wait for io)
    void shutdown() {
        {
            std::lock_guard<std::mutex> lock(_queue_mutex);
            _shutdown = true;
        }
        _condition.notify_one();
        if (_worker.joinable()) _worker.join();
    }

private:
    AsyncLogger() = default;
    ~AsyncLogger() { shutdown(); }

    struct LogEntry {
        LogLevel level;
        std::string message;
        const char* file;
        int line;
        std::chrono::system_clock::time_point time;
    };
    /**
     * 
    */
    void run() {
        while (true) {
            LogEntry entry;
            {
                std::unique_lock<std::mutex> lock(_queue_mutex);
                _condition.wait(lock, [this] { return !_log_queue.empty() || _shutdown; });
                if (_shutdown && _log_queue.empty()) break;
                if (!_log_queue.empty()) {
                    entry = _log_queue.front();
                    _log_queue.pop();
                    _current_queue_size--;

                    if (!_drop_when_full){
                        _condition_not_full.notify_one();
                    }
                }
            }

            write_to_file(entry);
            write_to_console(entry);
        }
    }

    void write_to_console(const LogEntry& entry) {
        if (!_console_output) return; 
        
        auto t = std::chrono::system_clock::to_time_t(entry.time);
        std::cout << "[" << std::put_time(std::localtime(&t), "%Y-%m-%d %H:%M:%S")
                  << "][" << entry.file << ":" << entry.line << "]["
                  << level_to_string(entry.level) << "] "
                  << entry.message << "\n";
    }

    void write_to_file(const LogEntry& entry) {
        // File roll refers to pt realization
        if (_file.tellp() > static_cast<std::streampos>(_max_size)) {
            std::lock_guard<std::mutex> lock(_file_mutex);
            _file.close();
            std::string new_name = _filename + "." + std::to_string(time(nullptr));
            std::rename(_filename.c_str(), new_name.c_str());
            _file.open(_filename, std::ios::out | std::ios::app);
        }

        // Format logï¼štimestamp + file name + row number + level + msg
        auto t = std::chrono::system_clock::to_time_t(entry.time);
        // Remind!!!!
        // Don't use localtime, will cause wrong when reading time because
        // All Thread WILL write to same static memory area
        // !!!
        // Use safe localtime_r
        std::tm tm_info;
        localtime_r(&t, &tm_info);
        _file << "[" << std::put_time(&tm_info, "%Y-%m-%d %H:%M:%S")
              << "][" << entry.file << ":" << entry.line << "]["
              << level_to_string(entry.level) << "] "
              << entry.message << "\n";
        _file.flush();
    }

    std::string level_to_string(LogLevel level) {
        switch (level) {
            case LogLevel::DEBUG: return "DEBUG";
            case LogLevel::INFO:  return "INFO";
            case LogLevel::WARN:  return "WARN";
            case LogLevel::ERROR: return "ERROR";
            case LogLevel::FATAL: return "FATAL";
            default: return "UNKNOWN";
        }
    }
    // Must be aware of oom, because consumer may cannot keep up with
    // the rate of log generating;
    // todo optimize: concurrent queue use self-rotate, further improve 
    // concurrency performance
    std::queue<LogEntry> _log_queue;
    std::mutex _queue_mutex;
    std::mutex _file_mutex;
    std::condition_variable _condition; //
    std::condition_variable _condition_not_full;
    std::thread _worker;
    std::ofstream _file{"app.log", std::ios::app};
    std::string _filename;
    size_t _max_size;
    size_t _max_queue_size = 1000;
    std::atomic<size_t> _current_queue_size{0};
    std::atomic<bool> _drop_when_full{true}; // Default discard latest logs
    std::atomic<bool> _shutdown{false};
    bool _console_output = false; 
};

#ifndef LOG_LEVEL
#define LOG_LEVEL LogLevel::INFO // Default
#endif

#define LOG(level, msg, ...) do { \
    if (level >= LOG_LEVEL) { \
        AsyncLogger::instance().enqueue(level, fmt::format(msg, ##__VA_ARGS__), __FILE__, __LINE__); \
    } \
} while (0)

// Simplify use
#define DEBUG_LOG(msg, ...) LOG(LogLevel::DEBUG, msg, ##__VA_ARGS__)
#define INFO_LOG(msg, ...)  LOG(LogLevel::INFO,  msg, ##__VA_ARGS__)
#define WARN_LOG(msg, ...)  LOG(LogLevel::WARN,  msg, ##__VA_ARGS__)
#define ERROR_LOG(msg, ...) LOG(LogLevel::ERROR, msg, ##__VA_ARGS__)
#define FATAL_LOG(msg, ...) LOG(LogLevel::FATAL, msg, ##__VA_ARGS__)